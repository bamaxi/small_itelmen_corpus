# Itelmen mini-corpus

Сайт <https://bamaxi.pythonanywhere.com>  
Логин:  admin  
Пароль: maximillian

Это попытка сделать корпус на *Flask*.
Используются также:
* базы данных (*SQLAlchemy*)
* *BeautifulSoup* для парсинга входных (и исходных) размеченных текстов

Содержание:
* [Запуск](#запуск)
* [Структура проекта](#структура-проекта)
* [О базе данных](#база-данных)
* [TO-DO](#to-do)
* [Работавшие над текстами](#работавшие-над-текстами)

## Запуск
Из папки, в которой расположены `run.py` и папка `app`:
1. Сделать виртуальную среду  
    `python -m venv corpus_venv`  
    активировать её  
    `corpus_env\Scipts\activate.bat` (Win)  
    (или `Activate.ps1` в powershell)
2. Установить из неё нужные пакеты  
    `pip install -r requirements.txt`
3. Для запуска в командной строке:  
    Unix:
    ```
       export FLASK_APP=run.py
       flask run
   ```   
    
   Windows:
   ```
       set FLASK_APP=run.py
       flask run
   ```

## Структура проекта
Основная логика приложения содержится в папке **`app`**. На верхнем уровне несколько папок это blueprint'ы для Flask:
* `main` - главная страница 
* `search` - поиск и результаты
* `upload` - страница загрузки своих размеченных текстов в корпус
* `errors` - свои страницы ошибок

Ещё есть такое:
* `update_db` - это тоже как бы blueprint, но так он не используется.
Здесь код для парсинга текстов (`parse.py`) и для добавления их в базу (`update.py`)
* `static` - с образцом `.xml` файла, который можно загрузить в корпус
и который должен распарситься
* `templates` - здесь хранятся шаблоны страниц по своим папкам и базовый шаблон,
из которому они наследуют
* если загружен хоть один файл, то будет ещё папка `upload_data` - там
загруженные кем-то на сервер файлы текстов. Эти тексты парсятся сразу после
загрузки. Должно вылезать сообщение, говорящее успешна загрузка или нет.

В **`app`** два исполняемых файла. Первый -- `__init__.py` создаёт экземпляр
приложения. Там какой-то сложный паттерн из ООП типа "фабрики классов" с `create_app()`
`return app`, я не разобрался, но вроде работает...
Второй файл для *SQLAlchemy* - `models.py`.
Через классы и их аттрибуты описывается логика таблиц.
В отдельных классах прописаны функции, которые
позволяют удобным образом что-то доставать.


В самом репозитории на самом верхнем уровне есть следующее:
* `xml_texts` - размеченные ительменские тексты.
Непосредственно программой они не используются, кроме `text_1.xml` если
запустить `start_db.py` (описано ниже). То есть в любом случае, чтобы тестировать
сайт можно брать оттуда тексты и загружать.
    * Есть странная проблема с PAW, когда *BeautifulSoup* (или встроенный
    *lxml parser*) не может распарсить тексты из файла `all_3_texts.xml`.
    Вообще-то это исходный файл, который был потом разбит на отдельные тексты.
    Странно, что такое происходит. У меня на компе и этот файл нормально парсится.
    *(все пакеты и весь код те же, потому что через гит делаю)*
* `migrations` - папка с настройками для БД, создаваемая *flask-migrate*.
Позволяет отслеживать и легко выполнять изменение логики базы данных.
    * [о структуре](#база-данных)
* `start_db.py` - код для создания с нуля БД. Использует *flask-migrate* и 
логику основного приложения. Можно просто сделать из командной строки `python start_db.py`
и он создаст базу данных, куда будет внесён размеченный текст из файла  `xml_texts/text_1.xml`
    * Но можно в интерпретаторе заимпортить оттуда функцию
    `add_data_from_file` и сделать первоначальным другой текст.
* `run.py` - это файл для запуска программы. Но на PAW кажется и не нужен.
Там прописаны функции для командной строки, поэтому можно сделать
`flask shell` и запустится интепретатор с контекстом приложения и доступом к
таблицам БД
* `requirements.txt` - пакеты...


## База данных
* `Text` - описывает текст (автор, название). Класс содержит список абзацей
 (ООП штука из *SQLAlchemy*, не входят в таблицу)
* `Paragraph` - описывает абзац (номер и внешний ключ для текста).
Аналогично `Text` содержит список предложений.
* `Phrase` - описывает предложение. Не id поле это перевод. Есть список слов
* `Word` - описывает словоформу. Есть словоформа, часть речи и перевод.
Есть список морфов.
* `Morph` - описывает морфы. Есть морф, его глубинная форма, тип (корень/аффикс),
глосса

Как говорил, например, у слова есть список морфов и т.д.
Это и в обратную сторону работает и по морфу можно доставать слово.
У меня есть функции достающие текст по слову.

## TO-DO
* Проверить, что поиск по слоям кроме глосс не чувствителен к
регистру
* Добавить часть разметки, которая парсится, но не добавлена в интерфейс  
  * глубинная форма
  * части речи слова и морфов
* **Выделять** найденные слова
* Добавить в код и в инструкцию при загрузке требование,
чтобы в xml был проставлен правильный `lang`.
`"itl"` для ительменского (?)
* Добавить тесты
* Код поиска в `app/search/search.py` надо сделать удобнее
* Таблица `Paragraphs` возможно не нужна
* Парсинг надо сделать асинхронным.
Сейчас приходится ждать его окончания перед загрузкой страницы.
Можно использовать *Celery*
* Подготовить к деплою в связке *Gunicorn* + *nginx*.
Возможно, полезен *Docker*
* миграция на flask-assets
   - переписать код на LESS
   
 

## Работавшие над текстами
Тексты из: Володин А. П. Ительменский язык. - Л.: Наука, 1976. - 426 с.   
Разметка: Карина Мищенкова, Софья Ганиева, Матвей Плугарёв  
